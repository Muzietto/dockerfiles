'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reloadConfig = reloadConfig;
exports.getOutputDir = getOutputDir;
exports.getExclusions = getExclusions;
exports.loadBabelPlugins = loadBabelPlugins;
exports.getPlugins = getPlugins;
exports.getBabelConfig = getBabelConfig;
exports.isProcessSerially = isProcessSerially;
exports.isVerbose = isVerbose;

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var pluginsBaseDir = '.';
var config = loadConfig();

/**
 * Load configuration at startup.
 * @return {Object} the configuration object
 */
function loadConfig() {
  // Load base configuration
  var config = {};

  try {
    config = (0, _readJsonSync2.default)('.npmbundlerrc');
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }

  // Apply preset if necessary
  if (config.preset) {
    var presetFile = _resolve2.default.sync(config.preset, {
      basedir: '.'
    });

    // Merge preset with base configuration
    config = Object.assign((0, _readJsonSync2.default)(presetFile), config);
    pluginsBaseDir = (0, _packages.getPackageDir)(presetFile);
  }

  return config;
}

/**
 * Require a module using the configured plugins directory.
 * @param {String} module a module name
 * @return {Object} the required module object
 */
function configRequire(module) {
  var pluginFile = _resolve2.default.sync(module, {
    basedir: pluginsBaseDir
  });

  return require(pluginFile);
}

/**
 * Force a config reload
 * @return {void}
 */
function reloadConfig() {
  config = loadConfig();
}

/**
 * Get the configured output directory
 * @return {String} the directory path (with native separators)
 */
function getOutputDir() {
  var dir = config['output'] || 'build/resources/main/META-INF/resources';
  return _path2.default.normalize(dir);
}

/**
 * Get the configured file exclusions for a given package.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Array} an array of glob expressions
 */
function getExclusions(pkg) {
  var exclusions = config.exclude || {};

  exclusions = exclusions[pkg.id] || exclusions[pkg.name] || exclusions['*'] || [];

  return exclusions;
}

/**
 * Load Babel plugins from a given array of presets and plugins.
 * @param {Array} presets an array of Babel preset names as defined by .babelrc
 * @param {Array} plugins an array of Babel plugins names as defined by .babelrc
 * @return {Array} the instantiated Babel plugins
 */
function loadBabelPlugins(presets, plugins) {
  var _concat, _ref;

  // TODO: if plugins have config decide what to do with it
  return (_concat = (_ref = []).concat.apply(_ref, _toConsumableArray(presets.map(function (preset) {
    var presetModule = void 0;

    try {
      presetModule = configRequire(preset);
    } catch (err) {
      presetModule = configRequire('babel-preset-' + preset);
    }

    return presetModule.default().plugins;
  })))).concat.apply(_concat, _toConsumableArray(plugins));
}

/**
 * Get the liferay-nmp-bundler plugins for a given package.
 * @param {String} phase 'pre' or 'post'
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Array} the instantiated Babel plugins
 */
function getPlugins(phase, pkg) {
  var pluginsKey = phase === 'pre' ? 'plugins' : 'post-plugins';

  var plugins = [];

  if (config[pkg.id] && config[pkg.id][pluginsKey]) {
    plugins = config[pkg.id][pluginsKey];
  } else if (config['*'] && config['*'][pluginsKey]) {
    plugins = config['*'][pluginsKey];
  }

  return plugins.map(function (pluginName) {
    var pluginConfig = {};

    if (Array.isArray(pluginName)) {
      pluginConfig = pluginName[1];
      pluginName = pluginName[0];
    }

    var pluginModule = configRequire('liferay-npm-bundler-plugin-' + pluginName);

    return {
      run: pluginModule.default,
      config: pluginConfig
    };
  });
}

/**
 * Get Babel config for a given package
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Object} a Babel configuration object as defined by its API
 */
function getBabelConfig(pkg) {
  var babelConfig = {};

  if (config[pkg.id] && config[pkg.id]['.babelrc']) {
    babelConfig = config[pkg.id]['.babelrc'];
  } else if (config['*'] && config['*']['.babelrc']) {
    babelConfig = config['*']['.babelrc'];
  }

  return babelConfig;
}

/**
 * Whether or not to process npm packages serially
 * @return {boolean}
 */
function isProcessSerially() {
  return config['process-serially'] || false;
}

/**
 * Whether or not to dump detailed information about what the tool is doing
 * @return {boolean}
 */
function isVerbose() {
  return config['verbose'] || false;
}
//# sourceMappingURL=config.js.map