'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (args) {
  var promises = [];

  var outputDir = _path2.default.resolve(config.getOutputDir());

  // Create work directories
  _fsExtra2.default.mkdirsSync(_path2.default.join(outputDir, 'node_modules'));

  // Copy project's package.json
  promises.push(copyRootPackageJson(outputDir));

  // Grab NPM dependencies
  var pkgs = (0, _dependencies.getPackageDependencies)('.');
  pkgs = Object.keys(pkgs).map(function (id) {
    return pkgs[id];
  });
  pkgs = pkgs.filter(function (pkg) {
    return pkg.dir != '.';
  });

  // Process NPM dependencies
  var start = process.hrtime();

  log.info('Bundling ' + pkgs.length + ' dependencies...');

  if (config.isProcessSerially()) {
    promises.push(iterateSerially(pkgs, function (pkg) {
      return bundlePackage(pkg, outputDir);
    }));
  } else {
    promises.push.apply(promises, _toConsumableArray(pkgs.map(function (pkg) {
      return bundlePackage(pkg, outputDir);
    })));
  }

  Promise.all(promises).then(function () {
    return log.info('Bundling took ' + (0, _prettyTime2.default)(process.hrtime(start)));
  }).catch(function (err) {
    log.error(err);
    process.exit(1);
  });
};

var _babelCore = require('babel-core');

var babel = _interopRequireWildcard(_babelCore);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _prettyTime = require('pretty-time');

var _prettyTime2 = _interopRequireDefault(_prettyTime);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _config = require('./config');

var config = _interopRequireWildcard(_config);

var _dependencies = require('./dependencies');

var _log = require('./log');

var log = _interopRequireWildcard(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Default entry point for the liferay-npm-bundler.
 * @param {Array} args the CLI arguments
 * @return {void}
 */


/**
 * Copy project root package.json file to output directory.
 * @param {String} outputDir the output directory path
 * @return {Promise} a Promise fulfilled when the copy has been finished
 */
function copyRootPackageJson(outputDir) {
  return _fsExtra2.default.copy('package.json', _path2.default.join(outputDir, 'package.json'));
}

/**
 * Iterate through the elements of an array applying an async process serially 
 * to each one of them.
 * @param {Array} values array of values to be iterated
 * @param {function} asyncProcess the async process (that returns a Promise) to 
 *        be executed on each value
 * @return {Promise} a Promise that is resolved as soon as the iteration 
 *         finishes
 */
function iterateSerially(values, asyncProcess) {
  return new Promise(function (resolve) {
    if (values.length == 0) {
      resolve();
      return;
    }

    var val = values[0];

    asyncProcess(val).then(function () {
      iterateSerially(values.slice(1), asyncProcess).then(function (result) {
        resolve();
      });
    });
  });
}

/**
 * Bundle a npm package
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @param {String} outputDir directory where bundled packages are placed
 * @return {Promise} a promise that is fulfilled when the package is bundled
 */
function bundlePackage(pkg, outputDir) {
  var outPkgDir = _path2.default.join(outputDir, 'node_modules', pkg.id.replace('/', '%2F'));

  try {
    if (_fsExtra2.default.statSync(outPkgDir).isDirectory()) {
      log.debug('Skipping ' + pkg.id + ' (already bundled)');
      return;
    }
  } catch (err) {}

  log.debug('Bundling ' + pkg.id);

  _fsExtra2.default.mkdirsSync(outPkgDir);

  return copyPackage(pkg, outPkgDir).then(function () {
    return pkg.dir = outPkgDir;
  }).then(function () {
    return processPackage('pre', pkg);
  }).then(function () {
    return runBabel(pkg);
  }).then(function () {
    return processPackage('post', pkg);
  }).then(function () {
    return log.debug('Bundled ' + pkg.id);
  });
}

/**
 * Copy an NPM package to output directory.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @param {String} dir the output directory path
 * @return {Promise} a Promise fulfilled when the copy has been finished
 */
function copyPackage(pkg, dir) {
  var exclusions = config.getExclusions(pkg);

  var globs = [pkg.dir + '/**/*', '!' + pkg.dir + '/node_modules/**/*'].concat(exclusions.map(function (exclusion) {
    return '!' + pkg.dir + '/' + exclusion;
  }));

  return (0, _globby2.default)(globs).then(function (paths) {
    paths = paths.filter(function (path) {
      return _fsExtra2.default.statSync(path).isFile();
    }).map(function (path) {
      return path.substring(pkg.dir.length + 1);
    });

    var promises = paths.map(function (path) {
      return _fsExtra2.default.copy(pkg.dir + '/' + path, dir + '/' + path);
    });

    return Promise.all(promises);
  });
}

/**
 * Process an NPM package with the configured liferay-nmp-bundler plugins. This
 * function is called two times (known as phases) per package: one before Babel 
 * runs and one after.
 * @param {String} phase 'pre' or 'post' depending on what phase we are in
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function processPackage(phase, pkg) {
  return new Promise(function (resolve, reject) {
    var pkgJsonPath = _path2.default.join(pkg.dir, 'package.json');
    var pkgJson = (0, _readJsonSync2.default)(pkgJsonPath);

    var state = {
      pkgJson: pkgJson
    };

    try {
      config.getPlugins(phase, pkg).forEach(function (plugin) {
        plugin.run({ pkg: pkg, config: plugin.config }, state);
      });
    } catch (err) {
      reject(err);
    }

    _fsExtra2.default.writeFileSync(pkgJsonPath, JSON.stringify(state.pkgJson, '', 2));

    resolve();
  });
}

/**
 * Run Babel on a package.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function runBabel(pkg) {
  var babelConfig = config.getBabelConfig(pkg);

  // Intercept presets and plugins to load them from here
  babelConfig.plugins = config.loadBabelPlugins(babelConfig.presets || [], babelConfig.plugins || []);
  babelConfig.presets = [];

  // Tune babel config
  babelConfig.babelrc = false;
  babelConfig.only = '**/*';
  if (babelConfig.sourceMaps === undefined) {
    babelConfig.sourceMaps = true;
  }

  // Run babel through it
  return (0, _globby2.default)([pkg.dir + '/**/*.js']).then(function (filePaths) {
    var promises = filePaths.map(function (filePath) {
      return new Promise(function (resolve, reject) {
        babel.transformFile(filePath, Object.assign({
          filenameRelative: filePath
        }, babelConfig), function (err, result) {
          if (err) {
            log.error('Error processing file: ' + filePath);
            reject(err);
          } else {
            var fileName = _path2.default.basename(filePath);

            _fsExtra2.default.writeFileSync(filePath, result.code + '\n' + ('//# sourceMappingURL=' + fileName + '.map'));

            _fsExtra2.default.writeFileSync(filePath + '.map', JSON.stringify(result.map));

            resolve();
          }
        });
      });
    });

    return Promise.all(promises);
  });
}
//# sourceMappingURL=index.js.map