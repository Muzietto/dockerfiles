{"version":3,"sources":["../src/index.js"],"names":["args","promises","outputDir","resolve","config","getOutputDir","mkdirsSync","join","push","copyRootPackageJson","pkgs","Object","keys","map","id","filter","pkg","dir","start","process","hrtime","log","info","length","isProcessSerially","iterateSerially","bundlePackage","Promise","all","then","catch","err","error","exit","babel","copy","values","asyncProcess","val","slice","outPkgDir","replace","statSync","isDirectory","debug","copyPackage","processPackage","runBabel","exclusions","getExclusions","globs","concat","exclusion","paths","path","isFile","substring","phase","reject","pkgJsonPath","pkgJson","state","getPlugins","forEach","plugin","run","writeFileSync","JSON","stringify","babelConfig","getBabelConfig","plugins","loadBabelPlugins","presets","babelrc","only","sourceMaps","undefined","filePaths","transformFile","filePath","assign","filenameRelative","result","fileName","basename","code"],"mappings":"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","file":"index.js","sourcesContent":["import * as babel from 'babel-core';\nimport fs from 'fs-extra';\nimport globby from 'globby';\nimport path from 'path';\nimport pretty from 'pretty-time';\nimport readJsonSync from 'read-json-sync';\n\nimport * as config from './config';\nimport {getPackageDependencies} from './dependencies';\nimport * as log from './log';\n\n/**\n * Default entry point for the liferay-npm-bundler.\n * @param {Array} args the CLI arguments\n * @return {void}\n */\nexport default function(args) {\n  let promises = [];\n\n  const outputDir = path.resolve(config.getOutputDir());\n\n  // Create work directories\n  fs.mkdirsSync(path.join(outputDir, 'node_modules'));\n\n  // Copy project's package.json\n  promises.push(copyRootPackageJson(outputDir));\n\n  // Grab NPM dependencies\n  let pkgs = getPackageDependencies('.');\n  pkgs = Object.keys(pkgs).map(id => pkgs[id]);\n  pkgs = pkgs.filter(pkg => pkg.dir != '.');\n\n  // Process NPM dependencies\n  const start = process.hrtime();\n\n  log.info(`Bundling ${pkgs.length} dependencies...`);\n\n  if (config.isProcessSerially()) {\n    promises.push(iterateSerially(pkgs, pkg => bundlePackage(pkg, outputDir)));\n  } else {\n    promises.push(...pkgs.map(pkg => bundlePackage(pkg, outputDir)));\n  }\n\n  Promise.all(promises)\n    .then(() => log.info(`Bundling took ${pretty(process.hrtime(start))}`))\n    .catch(function(err) {\n      log.error(err);\n      process.exit(1);\n    });\n}\n\n/**\n * Copy project root package.json file to output directory.\n * @param {String} outputDir the output directory path\n * @return {Promise} a Promise fulfilled when the copy has been finished\n */\nfunction copyRootPackageJson(outputDir) {\n  return fs.copy('package.json', path.join(outputDir, 'package.json'));\n}\n\n/**\n * Iterate through the elements of an array applying an async process serially \n * to each one of them.\n * @param {Array} values array of values to be iterated\n * @param {function} asyncProcess the async process (that returns a Promise) to \n *        be executed on each value\n * @return {Promise} a Promise that is resolved as soon as the iteration \n *         finishes\n */\nfunction iterateSerially(values, asyncProcess) {\n  return new Promise(resolve => {\n    if (values.length == 0) {\n      resolve();\n      return;\n    }\n\n    let val = values[0];\n\n    asyncProcess(val).then(() => {\n      iterateSerially(values.slice(1), asyncProcess).then(result => {\n        resolve();\n      });\n    });\n  });\n}\n\n/**\n * Bundle a npm package\n * @param {Object} pkg the package descriptor hash containing id, name, version\n *        and dir fields\n * @param {String} outputDir directory where bundled packages are placed\n * @return {Promise} a promise that is fulfilled when the package is bundled\n */\nfunction bundlePackage(pkg, outputDir) {\n  const outPkgDir = path.join(\n    outputDir,\n    'node_modules',\n    pkg.id.replace('/', '%2F')\n  );\n\n  try {\n    if (fs.statSync(outPkgDir).isDirectory()) {\n      log.debug(`Skipping ${pkg.id} (already bundled)`);\n      return;\n    }\n  } catch (err) {}\n\n  log.debug(`Bundling ${pkg.id}`);\n\n  fs.mkdirsSync(outPkgDir);\n\n  return copyPackage(pkg, outPkgDir)\n    .then(() => (pkg.dir = outPkgDir))\n    .then(() => processPackage('pre', pkg))\n    .then(() => runBabel(pkg))\n    .then(() => processPackage('post', pkg))\n    .then(() => log.debug(`Bundled ${pkg.id}`));\n}\n\n/**\n * Copy an NPM package to output directory.\n * @param {Object} pkg the package descriptor hash containing id, name, version\n *        and dir fields\n * @param {String} dir the output directory path\n * @return {Promise} a Promise fulfilled when the copy has been finished\n */\nfunction copyPackage(pkg, dir) {\n  const exclusions = config.getExclusions(pkg);\n\n  const globs = [`${pkg.dir}/**/*`, `!${pkg.dir}/node_modules/**/*`].concat(\n    exclusions.map(exclusion => `!${pkg.dir}/${exclusion}`)\n  );\n\n  return globby(globs).then(paths => {\n    paths = paths\n      .filter(path => fs.statSync(path).isFile())\n      .map(path => path.substring(pkg.dir.length + 1));\n\n    const promises = paths.map(path =>\n      fs.copy(`${pkg.dir}/${path}`, `${dir}/${path}`)\n    );\n\n    return Promise.all(promises);\n  });\n}\n\n/**\n * Process an NPM package with the configured liferay-nmp-bundler plugins. This\n * function is called two times (known as phases) per package: one before Babel \n * runs and one after.\n * @param {String} phase 'pre' or 'post' depending on what phase we are in\n * @param {Object} pkg the package descriptor hash containing id, name, version\n *        and dir fields\n * @return {Promise} a Promise fulfilled when the process has been finished\n */\nfunction processPackage(phase, pkg) {\n  return new Promise((resolve, reject) => {\n    const pkgJsonPath = path.join(pkg.dir, 'package.json');\n    const pkgJson = readJsonSync(pkgJsonPath);\n\n    let state = {\n      pkgJson: pkgJson,\n    };\n\n    try {\n      config.getPlugins(phase, pkg).forEach(plugin => {\n        plugin.run({pkg, config: plugin.config}, state);\n      });\n    } catch (err) {\n      reject(err);\n    }\n\n    fs.writeFileSync(pkgJsonPath, JSON.stringify(state.pkgJson, '', 2));\n\n    resolve();\n  });\n}\n\n/**\n * Run Babel on a package.\n * @param {Object} pkg the package descriptor hash containing id, name, version\n *        and dir fields\n * @return {Promise} a Promise fulfilled when the process has been finished\n */\nfunction runBabel(pkg) {\n  const babelConfig = config.getBabelConfig(pkg);\n\n  // Intercept presets and plugins to load them from here\n  babelConfig.plugins = config.loadBabelPlugins(\n    babelConfig.presets || [],\n    babelConfig.plugins || []\n  );\n  babelConfig.presets = [];\n\n  // Tune babel config\n  babelConfig.babelrc = false;\n  babelConfig.only = '**/*';\n  if (babelConfig.sourceMaps === undefined) {\n    babelConfig.sourceMaps = true;\n  }\n\n  // Run babel through it\n  return globby([`${pkg.dir}/**/*.js`]).then(filePaths => {\n    const promises = filePaths.map(\n      filePath =>\n        new Promise((resolve, reject) => {\n          babel.transformFile(\n            filePath,\n            Object.assign(\n              {\n                filenameRelative: filePath,\n              },\n              babelConfig\n            ),\n            (err, result) => {\n              if (err) {\n                log.error(`Error processing file: ${filePath}`);\n                reject(err);\n              } else {\n                const fileName = path.basename(filePath);\n\n                fs.writeFileSync(\n                  filePath,\n                  `${result.code}\\n` + `//# sourceMappingURL=${fileName}.map`\n                );\n\n                fs.writeFileSync(`${filePath}.map`, JSON.stringify(result.map));\n\n                resolve();\n              }\n            }\n          );\n        })\n    );\n\n    return Promise.all(promises);\n  });\n}\n"]}